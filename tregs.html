
<html>
<head>
	<meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>T-REGS</title>
	<meta property="og:title" content="T-REGS" />
	<meta property="og:description" content="T-REGS Project page." />
	<style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&display=swap');
   </style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
	<link rel="stylesheet" type="text/css" media="all" href="style/project-page.css" />
	<!-- SLOWS DOWN THE PAGE POLYFILL -->
	<!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> -->
	<script id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 
	<script>
	window.MathJax = {
	tex: {
		inlineMath: [['$', '$'], ['\\(', '\\)']],
		displayMath: [['$$', '$$'], ['\\[', '\\]']]
	}
	};
	</script>
</head>



<body>	
	<header class="site-header">
		<div class="site-header__inner">
			<!-- <div class="site-brand">Julie Mordacq</div> -->
			<nav class="site-nav">
				<ul>
					<li><a class="custom-link" style="color: var(--main-color);" href="#abstract">Overview</a></li>
					<li><a class="custom-link" style="color: var(--main-color);" href="#method">T-REG</a></li>
					<li><a class="custom-link" style="color: var(--main-color);" href="#tregs">T-REG for SSL</a></li>
					<li><a class="custom-link" style="color: var(--main-color);" href="#bibtex">Bibtex</a></li>
					<li><a class="custom-link" style="color: var(--main-color);" href="#acknowledgements">Acknowledgements</a></li>
				</ul>
			</nav>
		</div>
	</header>
	<div class="title">
		<h1>T-REGS: Minimum Spanning Tree Regularization for Self-Supervised Learning</h1>
		<br>

		<ul class="publication-authors ul" align="center">
			<li><a class="custom-link" href="https://jumdc.github.io/">Julie Mordacq</a><sup>1,2</sup></li>
			<li><a class="custom-link" href="https://davidlapous.github.io/">David Loiseaux</a><sup>1,2</sup></li>
			<li><a class="custom-link" href="https://vicky.kalogeiton.info/">Vicky Kalogeiton</a><sup>2</sup></li>
			<li><a class="custom-link" href="https://geometrica.saclay.inria.fr/team/Steve.Oudot/">Steve Oudot</a><sup>1,2</sup></li>
		</ul>
		<ul class="publication-institutions ul" align="center">	
			<li><sup>1</sup> Inria Saclay</span></li>
			<li><sup>2</sup> LIX, CNRS, École Polytechnique, IP Paris</span></li>
		</ul>
	</div>
	
	<br>
	<h3>NeurIPS 2025</h3>
	
	<!-- <h3>MIDL 2024</h3> -->
	
	<div align="center">
		<ul class="publication-links ul">
			<li><div class="box"><a class="box-link" href="">
				<img src="assets/arxiv-logomark-small-square.svg" width="20" height="20" style="margin-right: 0.5rem; vertical-align: middle;" alt="arXiv"> Paper</a></div></li>
			<li><div class="box"><a class="box-link" href="">
				<i class="fa-brands fa-github icon" style="margin-right: 0.5rem;"></i>Code</a></div></li>
		</ul>
		<br>
	
	</div>

	
	
	<div id="abstract" class="abstract">
			<!-- <h2>Overview</h2> -->
			<!-- based on the MST -->
			<p>
				Self-supervised learning (SSL) has emerged as a powerful paradigm for learning meaningful data representations without relying on human annotations. A dominant approach in this field is joint embedding self-supervised learning (JE-SSL), in which two networks are trained to produce similar embeddings for different views of the same image. Recent work has shown that effective JE-SSL methods produce representations that avoid <i>dimensional collapse</i> and promote <i>uniformity</i>.
			</p>

			<p>
				To encourage such properties, we explore a simple, geometry-based regularizer.
				Specifically, we consider the Minimum Spanning Tree ($\mathrm{MST}$) of the embeddings--a tree that connects all the points together, without any cycles and with the minimum possible total edge length.
				More precisely, for a point cloud $Z$, a spanning tree (ST) is an undirected graph $G=(V,E)$ on $Z$ that is connected and acyclic. 
				We define the length of $G$ as:
				\begin{equation}
					E(G) := \sum_{(z,z')\in E} \|z-z'\|_2
					\label{eq:alpha_length}
				\end{equation}
				A minimum spanning tree of $Z$, denoted by $\mathrm{MST}(Z)$, is an spanning tree of $Z$ that minimizes length $E$.

				
			<figure style="text-align: center; margin: 0; width: 100%;">
				<img style="display: block; margin: 0 auto; max-width: 30%;" src="assets/tregs/mst-plot.svg" alt="mst">
				<figcaption class="text legend" style="display: block; margin: 0 auto; max-width: 40%;">
					<b>Example of a minimum spanning tree in $2$-d.</b>
					$\mathrm{MST}(Z)$ connects the set of points $Z$ together, without any cycles and with the minimum possible total edge length.
				</figcaption>
			</figure>
			<p> 
				As the $\mathrm{MST}(Z)$ connects all points together, increasing the distances between them naturally increases the total length of the $\mathrm{MST}$.		
			</p>
			<figure style="text-align: center; margin: 0; width: 100%;">
				<img style="display: block; margin: 0 auto; max-width: 40%;" src="assets/tregs/scaled-mst-animation.gif" alt="mst-scaling">
				<figcaption class="text legend" style="display: block; margin: 0 auto; max-width: 40%;">
					The length of the $\mathrm{MST}$ scales under any rescaling of $Z$.
				</figcaption>
			</figure>
			<p>
				Thus, maximizing the $\mathrm{MST}$ length alone would cause the points to spread out indefinitely. However, additionally constraining them to a compact manifold would encourage full use of the representation space and prevent trivial scaling.
			</p>
			<p>
				Building on this idea, we propose T-REG, a regularizer that maximizes the $\mathrm{MST}$ length of embeddings while constraining them to the unit sphere.
				Here,  we present a intuitive view of this regularization, its connections to entropy-based statistical dimension estimation <a class="custom-link" href="http://www-stat.wharton.upenn.edu/~steele/Publications/PDF/Steele88a%20.pdf">(Steele,1988)</a> and its application to SSL: T-REGS.
			</p>
	</div>
	<br>	
	
	<div id="method" class="content">
		<h2>T-REG: Minimum Spanning Tree based Regularization</h2>
		<hr class="separator">
		<br>

		<div>
			<p>
				T-REG has two terms, given $Z = \{z_1, ..., z_n\}\subseteq\mathbb{R}^d$, the set of $n$ embeddings of dimension $d$:  
				<ul style="list-style-type: lower-roman; font-style: italic;">
					<li>A length-maximization loss $\mathcal{L}_{\text{E}}$ that decreases with the length of the minimum spanning tree:
					\begin{equation}
						\mathcal{L}_{\text{E}}(Z) = - \frac{1}{n} \,\text{E}(\mathrm{MST}({Z})),
					\end{equation}
					where $\text{E}(\mathrm{MST}({Z}))$ denotes the length of the $\mathrm{MST}$ of $Z$.
					<br> <br>
					</li>
					<li>A soft sphere-constraint $\mathcal{L}_{\text{S}}$ that increases with the distance to a fixed sphere $\mathbb{S}$, given by:
						\begin{equation}
						\mathcal{L}_\text{S}(Z) = \frac{1}{n} \sum_i (\Vert z_i\Vert_2 - 1)^2.
					\end{equation}
					</li>
				</ul>
				
		These two terms combined force the embeddings to lie on $\mathbb{S}$ (or close to it), while spreading them out along $\mathbb{S}$.

		Maximizing the MST length alone would cause the points to diverge to infinity; the sphere constraint prevents this by keeping the embeddings within a fixed region around $\mathbb{S}$.
		The overall T-REG loss combines these two terms:
		\begin{equation}\label{eq:TREG}
			\mathcal{L}_{\text{T-REG}}(Z) = \gamma\, \mathcal{L}_{\text{E}}(Z) + \lambda\,  \mathcal{L}_\text{S}(Z),
		\end{equation}
		where $\gamma$ and $\lambda$ are hyperparameters controlling the trade-off between spreading out the embeddings and maintaining them on the sphere.
			</p>
		
		</div>

		<br>
		<h2>Illustration of T-REG with synthetic data</h2>
		<br>

		<p style="text-align: justify; ">
			We apply T-REG alone to optimize a degenerate point cloud and analyze its behavior.
			<!-- We start  with a point cloud $X$ of 256 points in $\mathbb{R}^3$, in the shape of a T-REX. -->
		</p>
		<figure style="text-align: center; margin: 0; width: 100%;">
			<img style="display: block; margin: 0 auto; max-width: 70%;"src="assets/tregs/trex-tregs.gif" alt="T-REGS">
			<figcaption class="text legend" style="display: block; margin: 0 auto; max-width: 55%;">
				<b>$3$-d point cloud analysis with T-REG.</b> T-REG successfully spreads points uniformly on the sphere by combining MST length maximization and sphere constraint.
			</figcaption>
		</figure>
		<br>
		<p style="text-align: justify; ">
			T-REG successfully spreads points uniformly on the sphere.
			However, without the sphere constraint, the points diverge to infinity, as shown below:
		</p>
		<br>
		<figure style="text-align: center; margin: 0; width: 100%;">
			<img style="display: block; margin: 0 auto; max-width: 70%;" src="assets/tregs/trex-l_e.gif" alt="T-REGS" >
			<figcaption class="text legend" style="display: block; margin: 0 auto; max-width: 55%;">
				<b>$3$-d point cloud analysis with $\mathcal{L}_{\text{E}}$.</b> Using only MST length maximization leads to excessive dilation.
			</figcaption>
		</figure>
		


		<h2>Theoretical Analysis</h2>
		
		<div >
			<h3 style="text-align: left;">1. Behavior on small samples</h3>
			
			<p>
				We begin by considering the case where $n\le d+1$. It is particularly relevant since, in SSL, batch sizes are often smaller than or comparable to the ambient dimension. In order to account for the effect of the soft sphere constraint, we assume the points of $X$ lie inside some fixed closed Euclidean $d$-ball ${B}$ of radius $r$ centered at the origin.</p>
			
			<p class="box-math"><b>Theorem 1: </b>Under the above conditions, the maximum of $\text{E}({X})$ over the point sets $X\subset{B}$ of fixed cardinality $n$ is attained when the points of $X$ lie  on the sphere ${S}=\partial{B}$, at the vertices of a regular $(n-1)$-simplex that has ${S}$ as its  smallest circumscribing sphere.</p>
		
		<p>Theorem 1 explains the behavior of T-REG as follows: first, minimizing the term $\mathcal{L}_{\text{E}}$ in expands the point cloud until the sphere constraint term $\mathcal{L}_{\text{S}}$ becomes the dominating term (which happens eventually since $\mathcal{L}_{\text{S}}$ grows quadratically with the scaling factor, versus linearly for $\mathcal{L}_{\text{E}}$); at that stage, the points stop expanding and start spreading themselves out uniformly along the sphere of directions. The amount of expansion before spreading is prescribed by the strength of the sphere constraint term versus the term in the loss, which is driven by the ratio between their respective mixing parameters $\lambda$ and $\gamma$.</p>
		</div>

		<div >
			<h3 style="text-align: left;">2. Asymptotic behavior on large samples</h3>
			<p>We now consider the case where $n> d+1$, focusing specifically on the asymptotic behavior as $n\to\infty$. We analyze the constant $C$ in Theorem 1 of <a class="custom-link" href="http://www-stat.wharton.upenn.edu/~steele/Publications/PDF/Steele88a%20.pdf">(Steele, 1988)</a>, which can be made independent of the density of the sampling $X$. This, in particular, allows us to show that uniform and dimension-maximizing densities are asymptotically optimal for $E(\mathrm{MST}(\cdot))$. We fix a compact Riemannian $d$-manifold, $\mathcal{M}$, equipped with the $d$-dimensional Hausdorff measure $\mu$.</p>
			<p class="box-math"><b>Theorem 2,<a class="custom-link" href="https://link.springer.com/chapter/10.1007/0-8176-4481-4_9">(Costa et Hero, 2006)</a>:</b> Let $X_n$ be an iid $n$-sample of a probability measure on $\mathcal{M}$ with density $f_X$ w.r.t. $\mu$. Then, there exists a constant $C'$ independent of $f_X$ and of $\mathcal M$ such that:
				\begin{equation}
				n^{-\frac {d-1}{d}} \cdot \text{E}(X_n) \xrightarrow[n\to \infty]{}{C' \int f_X^{\frac{d-1}{d}}}\mathrm{d} \mu
				\quad
				\textnormal{almost surely.}
			\end{equation}</p>

			<p>As pointed out by <a class="custom-link" href="https://link.springer.com/chapter/10.1007/0-8176-4481-4_9">(Costa et Hero, 2006)</a>, 
				the limit in Theorem 2 is  related to theintrinsic Rényi $\frac{d-1}{d}$-entropy:
				\begin{equation}
					\varphi_{\frac{d-1}{d}}(f)  = \frac{1}{1-\frac{d-1}{d}} \log \int f^{\frac{d-1}{d}}\mathrm{d}\mu,
				\end{equation}
				which is known to converge to the Shannon entropy as $\frac{d-1}{d}\to
				1$ (Shannon Entropy, Renyi Entropy, and Information. Bromiley et al., 2004). The Shannon entropy (Maximum Entropy Autoregressive Conditional Heteroskedasticity Model. Park et al., 2009), in turn, achieves its maximum at the
				uniform distribution on compact sets (Maximum Entropy Autoregressive Conditional Heteroskedasticity Model. Park et al., 2009).</p>
		</div>
		
	</div>
	
	<div id="tregs" class="content">
		<h2>T-REGS: T-REG for SSL</h2>
		<hr class="separator">
		<br>
		<figure style="text-align: center; margin: 0; width: 100%;">
			<img style="display: block; margin: 0 auto; max-width: 90%;" src="assets/tregs/TREGS.svg" alt="T-REGS">
			<br>
			<figcaption class="text legend"><b>Overview of T-REGS.</b>
				<i>(Left)</i> Two augmented views $X, X'$ are encoded by $f_\theta$ and projected by $h_\phi$ into embeddings $Z, Z'$. Training jointly: <i>(i)</i> enforces view invariance via $\mathcal{L}_\text{SSL}(Z,Z')$ (MSE when used as a standalone regularizer, or a standard SSL loss when used as an auxiliary term); <i>(ii)</i> maximizes the minimum-spanning-tree length on each branch, $\mathcal{L}_\mathrm{E}(Z)$ and $\mathcal{L}_\mathrm{E}(Z')$, repelling edge-connected points in $\mathrm{MST}(Z)$ and  $\mathrm{MST}(Z')$; and <i>(iii)</i> applies sphere constraints $\mathcal{L}_\mathrm{S}(Z)$ and $\mathcal{L}_\mathrm{S}(Z')$.
				<i>(Right)</i> As a result, T-REGS induces uniformely distributed embeddings without dimensional collapse.
			</figcaption>
		</figure>
		<br>
		<p>
			<b>T-REGS</b> extend T-REG to self-supervised learning (SSL).
 
			We follow standard joint-embedding architectures. For an input image $i$, with augmented views $x=t(i)$ and $x'=t'(i)$, we compute embeddings $z=h_\phi(f_\theta(x))$ and 
			It acts as a regularization applied to the embedding batches $Z=[z_0, ..., z_n]$ and $Z'=[z'_0, ..., z'_n]$. 
			<br>
			It can be used as <i>(i)</i> a standalone regularization, combined directly with an invariance term, e.g., the Mean Squared Error (MSE): $\mathcal{L}_\text{MSE}(Z,Z') = \frac{1}{n} \sum_i \|z_i - z'_i\|_2^2$; or <i>(ii)</i> an auxiliary loss to existing self-supervised learning (SSL) methods. 
			We denote $\mathcal{L}_\text{SSL}$ as the objective function of a SSL method or the MSE term.
			<br>
			More specifically, embeddings from each view batch are treated as points in a high-dimensional space, and Kruskal's algorithm is used to construct the Minimum Spanning Tree ($\mathrm{MST}$) based on pairwise distances. The $\mathrm{MST}$ from both branches independently are then used to compute the T-REG regularization terms. 
			<br>
			Formally, the overall objective is defined as: 

			\begin{equation}
				\mathcal{L}(Z,Z') = \beta \, \mathcal{L}_\text{SSL}(Z,Z') + \underbrace{\gamma \, \mathcal{L}_\text{E}(Z) + \lambda \, \mathcal{L}_\text{S}(Z)}_{\mathcal{L}_\text{T-REG}(Z)} + \underbrace{\gamma \, \mathcal{L}_\text{E}(Z') + \lambda \, \mathcal{L}_\text{S}(Z')}_{\mathcal{L}_\text{T-REG}(Z')}
				\label{eq:loss} 
			\end{equation}
			where $\beta, \gamma, \lambda$ control the contribution of each term. 
		</p>
	</div>

	<div id="bibtex" class="content">
		<h2>Bibtex</h2>
		<hr class="separator">
		<div class="bibtex-container">
		   <button class="copy-btn" onclick="copyBibtex()" title="Copy BibTeX">
			   <i class="fa-solid fa-copy"></i> Copy BibTeX
		   </button>
		   <pre><code class="language-bibtex" id="bibtex-code">coming soon...<br>
		</code></pre>
	   </div>
	</div>
	</div>
	
	<div id="acknowledgements" class="content">
		<h2>Acknowledgements</h2>
		<hr class="separator">
		<p>This work was partially supported by Inria Action Exploratoire PreMediT (Precision Medicine using Topology). We were granted access to the HPC resources of IDRIS under the allocations 2025-AD011016121 and 2025-AD011016483 made by GENCI. 
		</p>
	</div>
	
</body>

</html>